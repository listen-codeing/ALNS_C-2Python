/*
🎯 solve_subproblem_with_LCFS 完整算法流程总结
====================================================

📚 算法背景：
- 输入：MP解决方案（包含充电决策 x_{v,j}）
- 目标：在固定充电决策下，优化充电站调度以最小化makespan
- 方法：Dynamic LCFS (Last Critical-path First Serve) 算法

🔄 算法流程：

┌─────────────────────────────────────────────────────────────┐
│ 第1步：初始化和数据准备                                        │
├─────────────────────────────────────────────────────────────┤
│ • 创建SP_solution对象                                         │
│ • 获取时间不确定性参数 xi_uncertainty                          │
│ • 从MP解决方案复制充电决策 isCharge[j]                         │
│ • 初始化AGV时间数组和状态数组                                  │
└─────────────────────────────────────────────────────────────┘
↓
┌─────────────────────────────────────────────────────────────┐
│ 第2步：calculate_initial_task_times                          │
├─────────────────────────────────────────────────────────────┤
│ • 假设无冲突，计算每个AGV的理想任务时间表                      │
│ • 考虑充电路径选择：tb_o (从充电站) vs te (直接移动)             │
│ • 加入时间不确定性缓冲 xi_uncertainty                         │
│ • 公式：start[j] = end[j-1] + uncertainty + travel_time      │
└─────────────────────────────────────────────────────────────┘
↓
┌─────────────────────────────────────────────────────────────┐
│ 第3步：LCFS_algorithm (核心算法)                │
├─────────────────────────────────────────────────────────────┤
│ 🕐 时间推进循环：while (T' < makespan)                        │
│                                                             │
│   🔍 扫描阶段：                                              │
│   • find_next_charging_task(): 找到需要充电的任务            │
│   • calculate_charging_start_time(): 计算充电时间窗          │
│   • has_charging_conflict(): 检测时间冲突                    │
│                                                             │
│   ⚔️ 冲突解决阶段：                                           │
│   • calculate_remaining_time(): 计算剩余关键路径 t^r         │
│   • 计算等待时间 t^w = max(0, start_time - current_time)     │
│   • 计算优先级 t^p = t^r - t^w                               │
│   • resolve_charging_conflict(): 高优先级AGV先充电           │
│   • reschedule_agv_after_delay(): 重调度延后的AGV           │
│                                                             │
│   ⏰ 时间推进：                                               │
│   • 无冲突：T' = max(所有充电结束时间)                        │
│   • 有冲突：解决冲突后重新扫描                                │
└─────────────────────────────────────────────────────────────┘
↓
┌─────────────────────────────────────────────────────────────┐
│ 第4步：生成最终结果                                           │
├─────────────────────────────────────────────────────────────┤
│ • generate_charging_station_schedule(): 生成充电记录         │
│ • calculate_makespan(): 计算最终makespan                     │
│ • 返回优化后的SP_solution                                     │
└─────────────────────────────────────────────────────────────┘

🔑 核心算法特点：

1. 📈 前向时间推进：
   - 按时间顺序处理事件，避免回溯
   - 每次冲突解决后重新开始扫描

2. 🎯 LCFS优先级规则：
   - 优先级 = 剩余关键路径长度 - 等待时间
   - 优先服务对makespan影响更大的AGV

3. 🔄 动态重调度：
   - 充电延后触发连锁反应
   - 重新计算所有受影响任务的时间

4. 🛡️ 鲁棒性保证：
   - xi_uncertainty提供时间缓冲
   - 处理旅行时间的不确定性

🎨 算法优势：

✅ 最优性：理论证明LCFS策略在多AGV充电调度中是最优的
✅ 效率：O(n²)时间复杂度，比精确MILP求解快得多
✅ 鲁棒性：考虑时间不确定性，提供可靠的调度方案
✅ 实用性：能处理复杂的多AGV、多任务、多充电场景

💡 与论文算法对应关系：
- 对应论文Algorithm 2: Dynamic LCFS Algorithm
- 实现了前向冲突解决方法
- 体现了Theorem 5的最优性保证
  */
  /*
  🎬 算法运行示例：2个AGV，3个任务
  =====================================

假设参数：
- tu = 5 (充电时间)
- xi_uncertainty = 1.0
- 充电决策来自MP：AGV0需要在任务1后充电，AGV1需要在任务0后充电

初始状态：
┌─────┬─────┬─────┬─────┬─────┬─────┬─────┐
│AGV  │任务0│     │任务1│     │任务2│     │
├─────┼─────┼─────┼─────┼─────┼─────┼─────┤
│ 0   │ 0-8 │     │10-18│ 🔋  │25-33│     │
│ 1   │ 0-7 │ 🔋  │15-23│     │26-34│     │
└─────┴─────┴─────┴─────┴─────┴─────┴─────┘
时间轴： 0    5    10   15   20   25   30   35

Step 1: calculate_initial_task_times()
=====================================
计算理想时间表（假设无冲突）：

AGV0:
- 任务0: [0, 8]
- 任务1: [10, 18] → 需要充电
- 任务2: [25, 33] (假设从充电站出发)

AGV1:
- 任务0: [0, 7] → 需要充电
- 任务1: [15, 23] (假设从充电站出发)
- 任务2: [26, 34]

Step 2: LCFS_algorithm()
====================================

🕐 时间推进 T' = 0:
找到充电需求：
- AGV1任务0 在时间7结束，请求充电 [9, 14]
- 队列Q = {(AGV1, 0, 9, 14)}
- 无冲突，时间推进到 T' = 14

🕐 时间推进 T' = 14:
找到充电需求：
- AGV0任务1 在时间18结束，请求充电 [20, 25]
- 队列Q = {(AGV0, 1, 20, 25)}
- 无冲突，时间推进到 T' = 25

如果充电时间重叠的情况：
假设两个AGV都在时间[18, 23]需要充电

🔍 冲突检测：
AGV0: [18, 23], AGV1: [19, 24] → 有重叠！

⚔️ LCFS冲突解决：
计算优先级分数：
- AGV0: t^r = 15 (剩余时间), t^w = 0 (等待), t^p = 15
- AGV1: t^r = 12 (剩余时间), t^w = 1 (等待), t^p = 11

决策：AGV0优先级更高，先充电
结果：AGV1延后到 [23, 28]

🔄 重调度连锁反应：
AGV1的任务1和任务2时间都需要重新计算

最终优化结果：
┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐
│AGV  │任务0│     │任务1│     │任务2│     │     │
├─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┤
│ 0   │ 0-8 │     │10-18│🔋18-23│25-33│     │     │
│ 1   │ 0-7 │🔋9-14 │15-23│     │26-34│     │     │
└─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘
时间轴： 0    5    10   15   20   25   30   35

最终makespan = 34

🎯 算法关键洞察：

1. 前向处理：按时间顺序解决冲突，避免重复计算
2. 局部最优：每次冲突都做出局部最优决策
3. 全局最优：局部最优决策的累积达到全局最优
4. 连锁更新：一个决策影响后续所有相关时间

这就是为什么Dynamic LCFS算法既高效又最优的原因！
*/